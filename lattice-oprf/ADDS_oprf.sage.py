

# This file was *autogenerated* from the file ADDS_oprf.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_64 = Integer(64); _sage_const_32 = Integer(32); _sage_const_8 = Integer(8); _sage_const_14 = Integer(14); _sage_const_1024 = Integer(1024); _sage_const_1000p0 = RealNumber('1000.0')
from datetime import date, datetime
import time

"""
A very rough (!) proof of concept implementation .
"""
from sage.all import matrix, vector
from sage.all import ceil, log, xgcd, next_prime, inverse_mod
from sage.all import ZZ, QQ, IntegerModRing
#from sage.misc.persist import SagePickler

class VOPRFPoC (object):
    """
    Figure 2
    """
    def __init__ (self, n, p, q):
        """
        Setup
        : param n : ring dimension, must be power of two
        : param p : rounding modulus
        : param q : computation modulus
        """
        self.q = q
        self.p = p
        self.n = n
        self.ell = ceil(log(q,_sage_const_2 ))

        # NOTE : we do modular reductions mod phi = X ^ n +1 hand
        self.R_Z = ZZ ["x"]
        self.X = self.R_Z.gen()
        self.phi = self.X**n + _sage_const_1 
        self.R = IntegerModRing(q)["x"]
        self.a = [vector (self.R, self.ell,[self.R.random_element (degree = n - _sage_const_1 ) for _ in range (self.ell)],) for _ in range (_sage_const_3 )]
        self.k = self.sample_small()
        self.c = self.a[_sage_const_2 ] * self.k + self.sample_small (scalar = False) # a [2] == a in Figure 2

    def bp14 (self, x, k =_sage_const_1 ):
        """
        Evaluate BP14 on input x and key k
        : param x : a vector of bits
        : param k : a small element in R
        """
        L = len(x)
        t = _sage_const_1 
        for i in range (_sage_const_1 , L)[:: -_sage_const_1 ]:
            t = self.ginv(self.modred(self.a[x[i]] * t))
        ax = self.modred(self.a[x[_sage_const_0 ]] * t)
        e = self.sample_small(scalar = False)
        return self.modred(ax * k) + e

    def sample_small (self, bound =_sage_const_1 , scalar = True):
        """
        Sample a small element in R or R ^ l
        : param bound : l_oo bound on coefficients
        : param scalar : if True return element in R, otherwise in R ^ l
        """
        if scalar :
            return self.R_Z.random_element (degree = self.n - _sage_const_1 , x = - bound, y = bound + _sage_const_1 )
        else :
            return vector (self.R_Z, self.ell, [self.sample_small () for _ in range (self.ell)],)

    def modred(self, v):
        """
        Reduce an element in R ^ l modulo phi
        : param v : an element in R ^ l
        """
        return vector(self.R, self.ell, [v_ % self.phi for v_ in v ])

    def nice_lift(self, h):
        """
        Return a balanced integer representation of an element in R .
        : param h : an element in R
        """
        r = []
        h = h % self.phi
        for e in h :
            if ZZ(e) > self.q // _sage_const_2 :
                r.append (ZZ (e) - self.q)
            else :
                r.append (ZZ (e))
        return self.R_Z (r)

    def ginv (self, a):
        """
        Return G^-1(a), i.e.bit decomposition .
        : param a : an element in R^l
        """
        A = matrix(self.R, self.ell, self.ell)
        for i in range(self.ell):
            a_ = a[i]. change_ring(ZZ)
            for j in range (self.ell):
                A[j, i] = self.R(
                    [(ZZ(a__) // _sage_const_2 **j) % _sage_const_2  for a__ in a_ ]
               )
        assert self.G * A == a
        return A

    @property
    def G (self):
        """
        Vector G = [1,2,4,...] in R ^ l
        """
        return vector(
                self.R, self.ell, [_sage_const_2 **i for i in range(self.ell)]
       )

    def __call__ (self, x):
        """
        Run the protocol on x, ignoring zero - knowledge proofs
        : param x : a vector of bits
        """
        # CLIENT
        s = self.sample_small(scalar = True)
        e1 = self.sample_small(scalar = False)
        cx = self.bp14(x) + self.a[_sage_const_2 ] * s + e1
        # SERVER
        e_ = self.sample_small(bound =_sage_const_2 **_sage_const_64 , scalar = False)
        dx = self.modred(cx * self.k + e_)
        # CLIENT
        y = self.nice_lift((dx - self.c * s)[_sage_const_0 ])
        return y // (self.q / self.p)

class AltVOPRFPoC (VOPRFPoC):
    """
    """

    def __init__ (self, n, p, q):
        """
        Setup
        : param n : ring dimension, must be power of two
        : param p : rounding modulus
        : param q : computation modulus
        """
        self.q = q
        self.p = p
        self.n = n
        self.ell = ceil(log(q,_sage_const_2 ))
        # NOTE : we do modular reductions mod phi = X ^ n +1 hand
        self.R_Z = ZZ["x"]
        self.X = self.R_Z.gen()
        self.phi = self.X**n + _sage_const_1 
        self.R = IntegerModRing(q)["x"]
        self.a = [
            vector (
                self.R,
                self.ell,
                [
                    self.R.random_element(degree = n - _sage_const_1 )
                    for _ in range(self.ell)
                ],
           )
            for _ in range(_sage_const_2 )
        ]
        self.k = self.sample_small()

def full_ntru (self, s, t):
    """
    Return small u,v  s.t. u * s + v * t = 1
    : param s : a small element in R
    : param t : a small element in R
    """
    Rs = s.resultant(self.phi)
    Rt = t.resultant(self.phi)
    u_ = (Rs * s.change_ring(QQ).inverse_mod(self.phi)) % self.phi
    v_ = (Rt * t.change_ring(QQ).inverse_mod(self.phi)) % self.phi
    r, u__, v__ = xgcd(Rs, Rt)
    u = u__ * u_
    v = v__ * v_
    u = u.change_ring(ZZ)
    v = v.change_ring(ZZ)

    def conjugate (f):
        ft = -f[self.n // _sage_const_2 ] * self.X**(self.n // _sage_const_2 ) + f[_sage_const_0 ]
        for i in range (_sage_const_1 , self.n // _sage_const_2 ):
            ft += (
                -f [ i ] * self.X ** (self.n - i)
                - f [ self.n - i ] * self.X ** i
           )
        return ft

    def xgcd_reduce (f, g, G, F):
        """
        https :// eprint.iacr.org /2019/015 solves f * G ' - g * F ' == f * G - g * F
        We map s,t,u, v to f,g, -G, F .
        """
        f, g, F, G = f, g, F, -G
        for j in range (_sage_const_32 ):
            num = (F * conjugate(f) + G * conjugate(g)) % self.phi
            den = (f * conjugate(f) + g * conjugate(g)) % self.phi
            k = (
                num
                * inverse_mod(den.change_ring(QQ), self.phi)
                % self.phi
            )
            k = sum (
                [
                    round(c) * self.X**i
                    for i, c in enumerate(list(k))
                ]
            )
            if k == _sage_const_0 :
                break
            F, G = (F - k * f) % self.phi, (G - k * g) % self.phi
        return -G, F

    u, v = xgcd_reduce (s, t, u, v)
    return u, v

def __call__ (self, x):
    """
    Run the protocol on x, ignoring zero - knowledge proofs
    : param x : a vector of bits
    """
    # CLIENT
    while True:
        s = self.sample_small()
        t = self.sample_small()
        u, v = self.full_ntru(s, t)
        if (u * s + v * t) % self.phi == _sage_const_1 :
            break
    c1 = self.bp14(x, s)
    c2 = self.bp14(x, t)
    # SERVER
    d1 = self.modred(
        c1 * self.k + self.sample_small(bound =_sage_const_2 **_sage_const_64 , scalar = False)
    ) # for " drowning "
    d2 = self.modred (
        c2 * self.k + self.sample_small(bound =_sage_const_2 **_sage_const_64 , scalar = False)
    )
    # CLIENT
    yx = self.nice_lift((u * d1 + v * d2)[_sage_const_0 ])
    return yx // (self.q / self.p)

# returns a list of bits representing the string s
def stringToBitList(s):
    l = []
    for c in s:
        for i in range(_sage_const_8 ):
            l.append((ord(c) >> (_sage_const_8  - i - _sage_const_1 )) % _sage_const_2 )
    return l

class MeasureVOPRF(VOPRFPoC):

    def sendClient(self, x):
        s = self.sample_small(scalar = True)
        e1 = self.sample_small(scalar = False)
        cx = self.bp14(x) + self.a[_sage_const_2 ] * s + e1
        return (cx,s)

    def sendServer(self, cx):
        e_ = self.sample_small(bound =_sage_const_2 **_sage_const_64 , scalar = False)
        dx = self.modred(cx * self.k + e_)
        return dx

    def recClient(self, dx, s):
        y = self.nice_lift((dx - self.c * s)[_sage_const_0 ])
        return y // (self.q / self.p)

    def __call__(self, x):
        (cx,s) = self.sendClient(x)
        f = open("Test_file_sage.txt", 'w')
        lenSend = (len(dumps(cx)))
        lenSend = (len(dumps(cx)))
        dx = self.sendServer(cx)
        lenRec = (len(dumps(cx)))
        print('Traffic = {}, lenSend = {}, lenRec = {}'.format((lenSend+lenRec), lenSend, lenRec))
        self.recClient(dx, s)
        return lenSend + lenRec



# instantiate with some toy parameters
#def test (cls = VOPRFPoC, p = 3, q_size =96, n =256):
def test (cls = VOPRFPoC, p = _sage_const_3 , q_size = _sage_const_14 , n = _sage_const_1024 ): #chosen as in newHope https://eprint.iacr.org/2015/1092.pdf

    print("starting...")
    q_ = next_prime (_sage_const_2  ** q_size)
    voprf = cls(n, p, p * q_)
    mvoprf = MeasureVOPRF(n, p, p * q_)
    print("test...")
    input_string = "abc"
    time_stamps = []
    space_stamps = []
    nr_iterations = _sage_const_1 
    for i in range(nr_iterations):
        print("Iteration nr. " + str(i))
        start = time.time()
        voprf(stringToBitList(input_string))
        measured = time.time() - start
        time_stamps.append(measured*_sage_const_1000p0 ) # milliseconds
        print("measured: " + str(measured))
        # Test traffic size
        netTraffic = mvoprf(stringToBitList(input_string))
        space_stamps.append(netTraffic)

    time_now = datetime.now()
    output_text = "Benchmark from " + str(date.today()) + " at " + time_now.strftime("%H:%M:%S")+ " with n = " + str(nr_iterations) + " iterations:\n"
    output_text += "User input: " + input_string + "\n"
    output_text += "-------------------------\n"
    avg_time = sum(time_stamps)/nr_iterations
    variance = sum([(t-avg_time)*(t-avg_time) for t in time_stamps]) / nr_iterations
    std_dev = sqrt(variance)
    output_text += "Measured time for each run:\n"
    output_text += str(time_stamps) + "\n"
    output_text += ("Average Time [ms]: " + str(avg_time) + "\n")
    output_text += ("Standard Deviation [ms]: " + str(std_dev) + "\n")
    avg_traffic = sum(space_stamps)/nr_iterations
    variance = sum([(t-avg_traffic)*(t-avg_traffic) for t in space_stamps]) / nr_iterations
    std_dev = sqrt(variance)
    output_text += "Measured traffic for each run:\n"
    output_text += str(space_stamps) + "\n"
    output_text += ("Average Traffic [Bytes]: " + str(avg_traffic) + "\n")
    output_text += ("Standard Deviation [Bytes]:std_dev: " + str(std_dev) + "\n")
    print(output_text)
    filename = "benchmark_results_{}_{}.txt".format(date.today(), time.strftime("%H_%M"))
    f = open(filename, 'w')
    f.write(output_text)

def main():
    test()

if __name__ == "__main__":
    main()


